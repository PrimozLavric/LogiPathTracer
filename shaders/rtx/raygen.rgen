#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "../common/ray.h"
#include "../common/random.h"
#include "uniforms.h"

layout(location = 0) rayPayloadNV RayPayload payload;

Ray generateRay() {
    vec2 jitter;

    float r1 = 2.0 * rand();
    float r2 = 2.0 * rand();

    jitter.x = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);
    jitter.y = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);
    jitter /= (gl_LaunchSizeNV.xy * 0.5);

    vec2 uv = 2.0 * vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy) - 1.0 + jitter;
    vec3 origin = ubo.camera.worldMatrix[3].xyz;

    float aspectRatio = gl_LaunchSizeNV.x / gl_LaunchSizeNV.y;
    uv.x *= aspectRatio * tan(ubo.camera.fovY / 2.0);
    uv.y *= tan(ubo.camera.fovY / 2);

    vec3 rayDir = normalize(uv.x * ubo.camera.worldMatrix[0].xyz + uv.y * ubo.camera.worldMatrix[1].xyz - ubo.camera.worldMatrix[2].xyz);

    return Ray(origin, rayDir);
}

void main() {
    vec2 resolution = imageSize(accumulationImage);
    seed = uvec2((ubo.sampleCount, ubo.sampleCount + 1) * gl_LaunchIDNV.xy);

    Ray ray = generateRay();

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;
    uint a = ubo.sampleCount;

    traceNV(accelerator, rayFlags, cullMask, 0, 0, 0, ray.origin, tmin, ray.direction, tmax, 0);

    imageStore(accumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(payload.mask, 0.0));
}