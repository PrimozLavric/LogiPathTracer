#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

#define INFINITY 3.4E+38
#define INTERSECTION_STACK_SIZE 64

struct Camera {
    mat4 worldMatrix;
    float fovY;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct BVHNode {
    vec3 minCorner;// Minumum bounding box point.
    vec3 maxCorner;// Maximum bounding box point.

    bool isLeaf;
/**
 * Indices of child nodes (if inner node).
 * Primitive indices range (if leaf node)  [first, last).
  */
    uvec2 indices;
};

struct Object {
    mat4 worldMatrix;// Object's world matrix.
    mat4 worldMatrixInverse;// Object's world matrix inverse.
    vec4 baseColorFactor;// Base color of the material (RGBA). Transparency not yet supported.
    vec3 emissionFactor;// Object's emissive factor (RGB)
    float metallicFactor;// Object's metallness factor (used to determin specular component strength).
    float roughnessFactor;// Object's roughness factor (used to determine diffuse component strength).
    uint bvhOffset;// Byte offset to object's BVH tree.
    uint verticesOffset;// Byte offset to object's vertices.
};

struct Vertex {
    vec3 position;
    vec3 normal;
};

struct Intersection {
    float distance;
    uint objectIndex;
    uint primitiveIndex;
};

layout (set = 0, binding = 0, rgba32f) uniform image2D accumulationImage;

layout (std140, set = 0, binding = 1) uniform UBO {
    Camera camera;
    uint sampleCount;
} ubo;

layout(std430, set = 0, binding = 2) buffer ObjectsBuffer {
    Object objects[];
};

layout(std430, set = 0, binding = 3) buffer ObjectBVHBuffer {
    BVHNode objectBVHNodes[];
};

layout(std430, set = 0, binding = 4) buffer TrianglesBuffer {
    Vertex vertices[];
};

layout(std430, set = 0, binding = 5) buffer TrianglesBVHBuffer {
    BVHNode meshBVHNodes[];
};


uvec2 seed;
float rand(){
    seed += uvec2(1);
    //return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453);
    uvec2 q = 1103515245U * ((seed >> 1U) ^ (seed.yx));
    uint  n = 1103515245U * ((q.x) ^ (q.y >> 3U));
    return float(n) * (1.0 / float(0xffffffffU));
}

vec3 barycentricCoord(vec3 point, vec3 v0, vec3 v1, vec3 v2) {
    vec3 ab = v1 - v0;
    vec3 ac = v2 - v0;
    vec3 ah = point - v0;

    float ab_ab = dot(ab, ab);
    float ab_ac = dot(ab, ac);
    float ac_ac = dot(ac, ac);
    float ab_ah = dot(ab, ah);
    float ac_ah = dot(ac, ah);

    float inv_denom = 1.0 / (ab_ab * ac_ac - ab_ac * ab_ac);

    float v = (ac_ac * ab_ah - ab_ac * ac_ah) * inv_denom;
    float w = (ab_ab * ac_ah - ab_ac * ab_ah) * inv_denom;
    float u = 1.0 - v - w;

    return vec3(u, v, w);
}

float rayAABBIntersect(Ray ray, vec3 minCorner, vec3 maxCorner) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 near = (minCorner - ray.origin) * invDir;
    vec3 far  = (maxCorner - ray.origin) * invDir;

    vec3 tmin = min(near, far);
    vec3 tmax = max(near, far);

    float t0 = max(max(tmin.x, tmin.y), tmin.z);
    float t1 = min(min(tmax.x, tmax.y), tmax.z);

    if (t0 > t1) {
        return INFINITY;
    }

    // If we are outside the box
    if (t0 > 0.0) {
        return t0;
    }

    // If we are inside the box.
    if (t1 > 0.0) {
        return t1;
    }

    return INFINITY;
}


float rayTriangleIntersect(Ray ray, vec3 v0, vec3 v1, vec3 v2) {
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 pvec = cross(ray.direction, edge2);
    float det = 1.0 / dot(edge1, pvec);

    vec3 tvec = ray.origin - v0;
    float u = dot(tvec, pvec) * det;
    if (u < 0.0 || u > 1.0) {
        return INFINITY;
    }

    vec3 qvec = cross(tvec, edge1);
    float v = dot(ray.direction, qvec) * det;
    if (v < 0.0 || u + v > 1.0) {
        return INFINITY;
    }

    return dot(edge2, qvec) * det;
}

Ray generateRay(vec2 resolution) {
    vec2 jitter;

    float r1 = 2.0 * rand();
    float r2 = 2.0 * rand();

    jitter.x = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);
    jitter.y = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);
    jitter /= (resolution * 0.5);

    vec2 uv = 2.0 * vec2(gl_GlobalInvocationID.xy) / vec2(resolution.x, resolution.y) - 1.0 + jitter;

    vec3 origin = ubo.camera.worldMatrix[3].xyz;

    float aspectRatio = resolution.x / resolution.y;
    uv.x *= aspectRatio * tan(ubo.camera.fovY / 2.0);
    uv.y *= tan(ubo.camera.fovY / 2);

    vec3 rayDir = normalize(uv.x * ubo.camera.worldMatrix[0].xyz + uv.y * ubo.camera.worldMatrix[1].xyz - ubo.camera.worldMatrix[2].xyz);

    return Ray(origin, rayDir);
}

void objectIntersect(Ray ray, uint objectIndex, inout Intersection intersection) {
    uint bvhOffset = objects[objectIndex].bvhOffset;
    uint verticesOffset = objects[objectIndex].verticesOffset;

    // Transform ray to object space
    Ray rayObjSpace;
    rayObjSpace.origin = vec3(objects[objectIndex].worldMatrixInverse * vec4(ray.origin, 1));
    rayObjSpace.direction = mat3(objects[objectIndex].worldMatrixInverse) * ray.direction;

    // Initialize stack.
    uint ptr = 0;
    int traversalStack[INTERSECTION_STACK_SIZE];
    traversalStack[ptr++] = -1;

    int idx = 0;
    while (idx > -1) {
        uint offsetIdx = bvhOffset + idx;

        // Determine if the ray intersects current node's AABB.
        float distanceAABB = rayAABBIntersect(rayObjSpace, meshBVHNodes[offsetIdx].minCorner, meshBVHNodes[offsetIdx].maxCorner);

        if (distanceAABB != INFINITY) {
            if (meshBVHNodes[offsetIdx].isLeaf) {
                // Test intersections.
                for (uint i = meshBVHNodes[offsetIdx].indices.x; i < meshBVHNodes[offsetIdx].indices.y; i++) {
                    uint firstVertexIdx = verticesOffset + 3 * i;
                    float triDistance = rayTriangleIntersect(rayObjSpace, vertices[firstVertexIdx].position, vertices[firstVertexIdx + 1].position, vertices[firstVertexIdx + 2].position);

                    if (triDistance < intersection.distance) {
                        intersection.distance = triDistance;
                        intersection.objectIndex = objectIndex;
                        intersection.primitiveIndex = firstVertexIdx;
                    }
                }
            } else {
                // If node is a branch add child nodes to stack.
                traversalStack[ptr++] = int(meshBVHNodes[offsetIdx].indices.x);
                traversalStack[ptr++] = int(meshBVHNodes[offsetIdx].indices.y);
            }
        }

        idx = traversalStack[--ptr];
    }
}

Intersection sceneIntersect(Ray ray) {
    Intersection intersection;
    intersection.distance = INFINITY;

    // Initialize stack.
    uint ptr = 0;
    int traversalStack[INTERSECTION_STACK_SIZE];
    traversalStack[ptr++] = -1;

    int idx = 0;

    while (idx > -1) {
        // Determine if the ray intersects current node's AABB.
        float distanceAABB = rayAABBIntersect(ray, objectBVHNodes[idx].minCorner, objectBVHNodes[idx].maxCorner);

        if (distanceAABB != INFINITY) {
            if (objectBVHNodes[idx].isLeaf) {
                // Test intersections.
                for (uint i = objectBVHNodes[idx].indices.x; i < objectBVHNodes[idx].indices.y; i++) {
                    objectIntersect(ray, i, intersection);
                }
            } else {
                // If node is a branch add child nodes to stack.
                traversalStack[ptr++] = int(objectBVHNodes[idx].indices.x);
                traversalStack[ptr++] = int(objectBVHNodes[idx].indices.y);
            }
        }

        idx = traversalStack[--ptr];
    }

    return intersection;
}

void main() {
    vec2 resolution = imageSize(accumulationImage);

    /*
     In order to fit the work into workgroups, some unnecessary threads are launched.
     We terminate those threads here.
     */
    if (gl_GlobalInvocationID.x >= resolution.x || gl_GlobalInvocationID.y >= resolution.y) {
        return;
    }

    seed = uvec2((ubo.sampleCount, ubo.sampleCount + 1) * gl_GlobalInvocationID.xy);

    Ray ray = generateRay(resolution);
    Intersection intersect = sceneIntersect(ray);

    // store to the storage buffer:
    if (ubo.sampleCount == 0) {
        imageStore(accumulationImage, ivec2(gl_GlobalInvocationID.xy), vec4(intersect.objectIndex / 9.0, 0.0, 0.0, 1.0));
    } else {
        imageStore(accumulationImage, ivec2(gl_GlobalInvocationID.xy), vec4(intersect.objectIndex / 9.0, 0.0, 0.0, 1.0));
    }
}