#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

#define EPS 0.03
#define PI 3.1415926535897932384626433832795
#define INFINITY 3.4E+38
#define INTERSECTION_STACK_SIZE 10
#define MAX_TRACE_DEPTH 10

#define RUSSIAN_ROULETTE_BOUNCES 2

// Interaction type
const uint kDiff = 0x00000001u;
const uint kSpec = 0x00000002u;
const uint kLight = 0x00000004u;
const uint kRefr = 0x00000008u;

struct Camera {
    mat4 worldMatrix;
    float fovY;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct BVHNode {
    vec3 minCorner;// Minumum bounding box point.
    vec3 maxCorner;// Maximum bounding box point.

    bool isLeaf;
/**
 * Indices of child nodes (if inner node).
 * Primitive indices range (if leaf node)  [first, last).
  */
    uvec2 indices;
};

struct Object {
    mat4 worldMatrix;// Object's world matrix.
    mat4 worldMatrixInverse;// Object's world matrix inverse.
    vec4 baseColorFactor;// Base color of the material (RGBA). Transparency not yet supported.
    vec3 emissionFactor;// Object's emissive factor (RGB)
    float metallicFactor;// Object's metallness factor (used to determin specular component strength).
    float roughnessFactor;// Object's roughness factor (used to determine diffuse component strength).
    uint bvhOffset;// Byte offset to object's BVH tree.
    uint verticesOffset;// Byte offset to object's vertices.
};

struct Vertex {
    vec3 position;
    vec3 normal;
};

struct Intersection {
    float distance;
    uint objectIndex;
    uint primitiveIndex;
};

layout (set = 0, binding = 0, rgba32f) uniform image2D accumulationImage;

layout (std140, set = 0, binding = 1) uniform UBO {
    Camera camera;
    uint sampleCount;
} ubo;

layout(std430, set = 0, binding = 2) buffer ObjectsBuffer {
    Object objects[];
};

layout(std430, set = 0, binding = 3) buffer ObjectBVHBuffer {
    BVHNode objectBVHNodes[];
};

layout(std430, set = 0, binding = 4) buffer TrianglesBuffer {
    Vertex vertices[];
};

layout(std430, set = 0, binding = 5) buffer TrianglesBVHBuffer {
    BVHNode meshBVHNodes[];
};


uvec2 seed;
float rand(){
    seed += uvec2(1);
    //return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453);
    uvec2 q = 1103515245U * ((seed >> 1U) ^ (seed.yx));
    uint  n = 1103515245U * ((q.x) ^ (q.y >> 3U));
    return float(n) * (1.0 / float(0xffffffffU));
}

vec3 barycentricCoord(vec3 point, vec3 v0, vec3 v1, vec3 v2) {
    vec3 ab = v1 - v0;
    vec3 ac = v2 - v0;
    vec3 ah = point - v0;

    float ab_ab = dot(ab, ab);
    float ab_ac = dot(ab, ac);
    float ac_ac = dot(ac, ac);
    float ab_ah = dot(ab, ah);
    float ac_ah = dot(ac, ah);

    float inv_denom = 1.0 / (ab_ab * ac_ac - ab_ac * ab_ac);

    float v = (ac_ac * ab_ah - ab_ac * ac_ah) * inv_denom;
    float w = (ab_ab * ac_ah - ab_ac * ab_ah) * inv_denom;
    float u = 1.0 - v - w;

    return vec3(u, v, w);
}

float rayAABBIntersect(Ray ray, vec3 minCorner, vec3 maxCorner) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 near = (minCorner - ray.origin) * invDir;
    vec3 far  = (maxCorner - ray.origin) * invDir;

    vec3 tmin = min(near, far);
    vec3 tmax = max(near, far);

    float t0 = max(max(tmin.x, tmin.y), tmin.z);
    float t1 = min(min(tmax.x, tmax.y), tmax.z);

    if (t0 > t1) {
        return INFINITY;
    }

    // If we are outside the box
    if (t0 > 0.0) {
        return t0;
    }

    // If we are inside the box.
    if (t1 > 0.0) {
        return t1;
    }

    return INFINITY;
}

float rayTriangleIntersect(Ray ray, vec3 v0, vec3 v1, vec3 v2) {
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 pvec = cross(ray.direction, edge2);
    float det = 1.0 / dot(edge1, pvec);

    vec3 tvec = ray.origin - v0;
    float u = dot(tvec, pvec) * det;
    if (u < 0.0 || u > 1.0) {
        return INFINITY;
    }

    vec3 qvec = cross(tvec, edge1);
    float v = dot(ray.direction, qvec) * det;
    if (v < 0.0 || u + v > 1.0) {
        return INFINITY;
    }

    return dot(edge2, qvec) * det;
}

Ray generateRay(vec2 resolution) {
    vec2 jitter;

    float r1 = 2.0 * rand();
    float r2 = 2.0 * rand();

    jitter.x = r1 < 1.0 ? sqrt(r1) - 1.0 : 1.0 - sqrt(2.0 - r1);
    jitter.y = r2 < 1.0 ? sqrt(r2) - 1.0 : 1.0 - sqrt(2.0 - r2);
    jitter /= (resolution * 0.5);

    vec2 uv = 2.0 * vec2(gl_GlobalInvocationID.xy) / vec2(resolution.x, resolution.y) - 1.0 + jitter;

    vec3 origin = ubo.camera.worldMatrix[3].xyz;

    float aspectRatio = resolution.x / resolution.y;
    uv.x *= aspectRatio * tan(ubo.camera.fovY / 2.0);
    uv.y *= tan(ubo.camera.fovY / 2);

    vec3 rayDir = normalize(uv.x * ubo.camera.worldMatrix[0].xyz + uv.y * ubo.camera.worldMatrix[1].xyz - ubo.camera.worldMatrix[2].xyz);

    return Ray(origin, rayDir);
}

void objectIntersect(Ray ray, uint objectIndex, inout Intersection intersection) {
    uint bvhOffset = objects[objectIndex].bvhOffset;
    uint verticesOffset = objects[objectIndex].verticesOffset;

    // Transform ray to object space
    Ray rayObjSpace;
    rayObjSpace.origin = vec3(objects[objectIndex].worldMatrixInverse * vec4(ray.origin, 1.0));
    rayObjSpace.direction = mat3(objects[objectIndex].worldMatrixInverse) * ray.direction;

    // Initialize stack.
    uint ptr = 0;
    int traversalStack[INTERSECTION_STACK_SIZE];
    traversalStack[ptr++] = -1;

    int idx = 0;
    while (idx > -1) {
        uint offsetIdx = bvhOffset + idx;

        // Determine if the ray intersects current node's AABB.
        float distanceAABB = rayAABBIntersect(rayObjSpace, meshBVHNodes[offsetIdx].minCorner, meshBVHNodes[offsetIdx].maxCorner);

        if (distanceAABB != INFINITY) {
            if (meshBVHNodes[offsetIdx].isLeaf) {
                // Test intersections.
                for (uint i = meshBVHNodes[offsetIdx].indices.x; i < meshBVHNodes[offsetIdx].indices.y; i++) {
                    uint firstVertexIdx = verticesOffset + 3 * i;
                    float triDistance = rayTriangleIntersect(rayObjSpace, vertices[firstVertexIdx].position, vertices[firstVertexIdx + 1].position, vertices[firstVertexIdx + 2].position);

                    if (triDistance < intersection.distance) {
                        intersection.distance = triDistance;
                        intersection.objectIndex = objectIndex;
                        intersection.primitiveIndex = firstVertexIdx;
                    }
                }
            } else {
                // If node is a branch add child nodes to stack.
                traversalStack[ptr++] = int(meshBVHNodes[offsetIdx].indices.x);
                traversalStack[ptr++] = int(meshBVHNodes[offsetIdx].indices.y);
            }
        }

        idx = traversalStack[--ptr];
    }
}

Intersection sceneIntersect(Ray ray) {
    Intersection intersection;
    intersection.distance = INFINITY;

    // Initialize stack.
    uint ptr = 0;
    int traversalStack[INTERSECTION_STACK_SIZE];
    traversalStack[ptr++] = -1;

    int idx = 0;

    while (idx > -1) {
        // Determine if the ray intersects current node's AABB.
        float distanceAABB = rayAABBIntersect(ray, objectBVHNodes[idx].minCorner, objectBVHNodes[idx].maxCorner);

        if (distanceAABB != INFINITY) {
            if (objectBVHNodes[idx].isLeaf) {
                // Test intersections.
                for (uint i = objectBVHNodes[idx].indices.x; i < objectBVHNodes[idx].indices.y; i++) {
                    objectIntersect(ray, i, intersection);
                }
            } else {
                // If node is a branch add child nodes to stack.
                traversalStack[ptr++] = int(objectBVHNodes[idx].indices.x);
                traversalStack[ptr++] = int(objectBVHNodes[idx].indices.y);
            }
        }

        idx = traversalStack[--ptr];
    }

    return intersection;
}


uint determineInteractionType(vec3 emissionFactor, float roughnessFactor, float metallicFactor, float opacity) {
    if (opacity < 1.0f) {
        return kRefr;
    }

    float avgEmissionFactor = (emissionFactor.x + emissionFactor.y + emissionFactor.z) / 3.0f;
    float maxRand = roughnessFactor + metallicFactor + avgEmissionFactor;
    if (maxRand == 0.0f) {
        return kDiff;
    }

    float r = rand() * maxRand;

    if (r < roughnessFactor) {
        return kDiff;
    } else if (r < roughnessFactor + metallicFactor) {
        return kSpec;
    } else {
        return kLight;
    }
}


float calcFresnelReflectance(vec3 n, vec3 nl, vec3 rayDirection, float nc, float nt, out vec3 tdir) {
    float nnt = dot(rayDirection, n) < 0.0 ? (nc / nt) : (nt / nc);

    tdir = refract(rayDirection, nl, nnt);

    // Original Fresnel equations
    float cosThetaInc = dot(nl, rayDirection);
    float cosThetaTra = dot(nl, tdir);
    float coefPara = (nt * cosThetaInc - nc * cosThetaTra) / (nt * cosThetaInc + nc * cosThetaTra);
    float coefPerp = (nc * cosThetaInc - nt * cosThetaTra) / (nc * cosThetaInc + nt * cosThetaTra);

    return (coefPara * coefPara + coefPerp * coefPerp) * 0.5; // Unpolarized
}


vec3 traceRay(Ray ray) {

    vec3 accColor = vec3(0.0, 0.0, 0.0);
    vec3 mask = vec3(1.0, 1.0, 1.0);

    for (uint bounce = 0; bounce < MAX_TRACE_DEPTH; bounce++) {
        Intersection isect = sceneIntersect(ray);

        // Missed.
        if (isect.distance == INFINITY) {
            break;
        }

        vec4 baseColorFactor = objects[isect.objectIndex].baseColorFactor;
        vec3 emissionFactor = objects[isect.objectIndex].emissionFactor;
        float roughnessFactor = objects[isect.objectIndex].roughnessFactor;
        float metallicFactor = objects[isect.objectIndex].metallicFactor;
        float opacity = baseColorFactor.w;

        // Determine interaction type based on the emission, roughness and metalic factor and opacity.
        uint interaction = determineInteractionType(emissionFactor, roughnessFactor, metallicFactor, opacity);

        // Compute normal
        if (interaction == kLight) {
            accColor = mask * emissionFactor * 10.0f;
        } else {
            Ray rayObjSpace;
            rayObjSpace.origin = vec3(objects[isect.objectIndex].worldMatrixInverse * vec4(ray.origin, 1));
            rayObjSpace.direction = mat3(objects[isect.objectIndex].worldMatrixInverse) * ray.direction;

            vec3 isectPositionWorld = ray.origin + isect.distance * ray.direction;
            vec3 bary = barycentricCoord(rayObjSpace.origin + isect.distance * rayObjSpace.direction, vertices[isect.primitiveIndex].position, vertices[isect.primitiveIndex + 1].position, vertices[isect.primitiveIndex + 2].position);
            vec3 normal = normalize(mat3(objects[isect.objectIndex].worldMatrix) * (bary.x * vertices[isect.primitiveIndex].normal + bary.y * vertices[isect.primitiveIndex + 1].normal + bary.z * vertices[isect.primitiveIndex + 2].normal));

            vec3 ffNormal = (dot(normal, ray.direction) < 0.0f) ? normal : normal * -1.0f;// front facing normal

            if (interaction == kDiff) {
                float r1 = 2.0f * PI * rand();// pick random number on unit circle (radius = 1, circumference = 2*Pi) for azimuth
                float r2 = rand();// pick random number for elevation
                float r2s = sqrt(r2);

                vec3 u = normalize(cross((abs(ffNormal.x) > 0.1f ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f)), ffNormal));
                vec3 v = cross(ffNormal, u);

                ray.origin = isectPositionWorld + EPS * ffNormal;
                ray.direction = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + ffNormal * sqrt(1.0f - r2));

                mask *= vec3(baseColorFactor);
                mask *= dot(ray.direction, ffNormal);
            } else if (interaction == kSpec) {
                mask *= vec3(baseColorFactor);
                ray.origin = isectPositionWorld + EPS * ffNormal;
                ray.direction = reflect(ray.direction, ffNormal);
            } else if (interaction == kRefr) {
                float nc = 1.0f;
                float nt = 1.5f;
                vec3 tdir;

                float Re = calcFresnelReflectance(normal, ffNormal, ray.direction, nc, nt, tdir);

                float r = rand();

                if (r < Re) { // reflect ray from surface
                    ray.origin = isectPositionWorld + EPS * ffNormal;
                    ray.direction = reflect(ray.direction, ffNormal);
                } else { // transmit ray through surface
                    mask *= vec3(baseColorFactor) * (1.0f - opacity);
                    ray.origin = isectPositionWorld - EPS * ffNormal;
                    ray.direction = tdir;
                }
            } else {
                // Unknown interaction.
                break;
            }
        }

        if (length(mask) < 0.5 && bounce > RUSSIAN_ROULETTE_BOUNCES) {
            float q = max(0.05f, 1.0f - length(mask));
            if (rand() < q) {
                break;
            }
            mask /= 1.0f - q;
        }
    }

    return accColor;
}

void main() {
    vec2 resolution = imageSize(accumulationImage);

    /*
     In order to fit the work into workgroups, some unnecessary threads are launched.
     We terminate those threads here.
     */
    if (gl_GlobalInvocationID.x >= resolution.x || gl_GlobalInvocationID.y >= resolution.y) {
        return;
    }

    seed = uvec2((ubo.sampleCount, ubo.sampleCount + 1) * gl_GlobalInvocationID.xy);

    Ray ray = generateRay(resolution);

    vec3 sampleColor = traceRay(ray);

    // store to the storage buffer:
    if (ubo.sampleCount == 0) {
        imageStore(accumulationImage, ivec2(gl_GlobalInvocationID.xy), vec4(sampleColor, 1.0));
    } else {
        imageStore(accumulationImage, ivec2(gl_GlobalInvocationID.xy), ((imageLoad(accumulationImage, ivec2(gl_GlobalInvocationID.xy)) * ubo.sampleCount) + vec4(sampleColor, 1.0)) / (ubo.sampleCount + 1));
    }
}